# flake8: noqa

import sys

import time
import numpy as np
from PIL import Image
from tqdm import tqdm

#SAMPLE_IMAGE_PATH = "InputImage.png"
#SAMPLE_IMAGE_PATH = "sample_image.png"

# --------------------- END TODO ---------------------------

def compute_energy(image):
    
    # Pad the image to avoid boundary checks
    padded_image = np.pad(image, ((1, 1), (1, 1), (0, 0)), mode='constant')

    # Compute squared differences in the x and y directions
    delta_x_squared = np.sum((padded_image[1:-1, 2:, :] - padded_image[1:-1, :-2, :]) ** 2, axis=2)
    delta_y_squared = np.sum((padded_image[2:, 1:-1, :] - padded_image[:-2, 1:-1, :]) ** 2, axis=2)

    # Compute the energy as the square root of the sum of squared differences
    energy = np.sqrt(delta_x_squared + delta_y_squared)

    # Set energy values for border pixels to 1000
    energy[:1, :] = 1000
    energy[-1:, :] = 1000
    energy[:, :1] = 1000
    energy[:, -1:] = 1000
    
    return energy
    # --------------------- END TODO ---------------------------


def find_vertical_seam(image: np.ndarray, energy=None):
    """
    Find the vertical "seam" with the least cumulative energy and return
    a list/array of the horizontal indices of the seam

    Input:
        image: int type np.ndarray of the shape:
            (image height, image width, number of color channels)
        energy: double type np.ndarray of the shape:
            (image height, image width)
            used for grading purposes to circumvent energy calculation

    Return:
        An (image height, ) sized array of integers ranging between
        [0, image width - 1]
    """

    # compute energy if not provided.
    if energy is None:
        energy = compute_energy(image)
        # Add a small random noise to the energy, which is generated by
        # an image assumed to contain integer values between [0, 255]
        # (thus may contain many duplicate values), to avoid variations
        # between implementations yielding different results.

        # Storing the internal random state for later reversion
        random_state = np.random.get_state()
        # Seeding the random state to 0
        np.random.seed(0)
        # generating the random noise
        noise = np.random.randn(*energy.shape) / (1000 * (image.size ** (0.5)))
        energy = energy + noise
        # Reverting the random state to what we started with
        np.random.set_state(random_state)

    # The vertical seam of least cumulative energy is defined as:
    #     A (image height, ) sized array of indices in the range
    #     [0, image width - 1], such that each pair of consecutive indices
    #     differ by no more than 1, and such that the sum of the energy on
    #     these pixels is the smallest that can be constructed from such a path
    #
    # This, when visualized on an image, would translate to a squiggly line
    # down an image. Deleting these pixels would yield 2 pieces of image
    # that, when pieced together, would result in an image exactly 1 pixel
    # narrower than the original
    
    #Get the height and width of the given image
    height = energy.shape[0]
    width = energy.shape[1]

    #create a 2d array of zeros (min2dArr[height][width]) to hold minimal values for DP approach 
    #min2dArr = np.array([[0 for i in range(width)] for j in range(height)], float)
    min2dArr = np.zeros((height, width), dtype=float)

    #copy the bottom row of energy values from energy array to min2dArr array
    # for i in range(width):
    #     min2dArr[height - 1][i] = energy[height - 1][i]
    min2dArr[height - 1] = energy[height - 1]

    #Iterate from the second-to-last row to the first (top) row.
    #height - 2 means we start the loop at the second to last row from the bottom.
    #The first -1 is the stopping point for the iteration. The loop will continue until it reaches 
    # the row with index -1. Note that the stopping point is not included in the iteration, 
    # so it stops just before reaching the top row.
    for i in range(height - 2, -1, -1):
        for j in range(width):
            # Handle cases for the left-most energy values.
            if j == 0:
                min2dArr[i, j] = energy[i, j] + min(min2dArr[i+1, j], min2dArr[i+1, j+1])
            # Handle cases for the right-most energy values.
            elif j == width - 1:
                min2dArr[i, j] = energy[i, j] + min(min2dArr[i+1, j-1], min2dArr[i+1, j])
            else:
                # For pixels in between, consider all three directions.
                min2dArr[i, j] = energy[i, j] + min(min2dArr[i+1, j-1], min2dArr[i+1, j], min2dArr[i+1, j+1])
    
    #Create a 1d np array that will represent least energy path where
    #each element is a pixel in each row of our seam.
    #leastEnergyVertSeam = np.array([0 for i in range(height)])
    leastEnergyVertSeam = np.zeros(height, dtype=int)
    
    #Get the index where the minimum energy pixel is in the top row of the min2dArr
    leastEnergyVertSeam[0] = np.argmin(min2dArr[0])

    for i in range(1, height):
        # Get the index of the minimum energy value among the adjacent pixels
        neighbor_indices = [leastEnergyVertSeam[i-1] - 1, leastEnergyVertSeam[i-1], leastEnergyVertSeam[i-1] + 1]
        
        try:
            min_index = min(neighbor_indices, key=lambda x: min2dArr[i, x])
        except:
            continue

        # Update the current row with the index of the minimum energy value
        leastEnergyVertSeam[i] = min_index
    
    return leastEnergyVertSeam

    # --------------------- END TODO ---------------------------

# def find_horizontal_seam(image: np.ndarray, energy=None):
def find_horizontal_seam(image: np.ndarray, energy=None):
    """
    Find the horizontal "seam" with the least cumulative energy and return
    a list/array of the vertical indices of the seam

    Input:
        image: int type np.ndarray of the shape:
            (image height, image width, number of color channels)
        energy: double type np.ndarray of the shape:
            (image height, image width)
            used for grading purposes to circumvent energy calculation

    Return:
        An (image width, ) sized array of integers ranging between
        [0, image height - 1]
    """

    # this is equivalent to finding the vertical seam on the transposed image
    # so we don't need to repeat ourselves
    return find_vertical_seam(image.transpose(1, 0, 2), energy=energy)


def main():
    """
    Generate a visualization of the energy and 2 visualizations
    of the seam carving algorithm.
    """
    
    if len(sys.argv) != 2:
        print('usage: seam_carver.py <image_file>', file=sys.stderr)
        sys.exit(1)
    
    SAMPLE_IMAGE_PATH = sys.argv[1]
    
    vert_Count = 0
    horz_Count = 0
    # open image with pillow, an active fork of the defunct PIL library
    p = Image.open(SAMPLE_IMAGE_PATH)
    # image could be other modes like RGBA, YCbCr, or L or something
    p = p.convert(mode="RGB")
    # limit max size
    p.thumbnail(size=(800, 500))
    R, G, B = 0, 1, 2

    # -------------------- energy -------------------------------

    # convert image to an array. Since default datatype for an RGB
    # image is in unsigned 8 bit integer, convert it to a regular int
    # to avoid hard-to-debug shenanigans like over/underflow
    image = np.array(p).astype(int)
    # compute the energy. Since the boundary is 1000 and would reduce
    # the visibility of the more interesting parts after normalization,
    # crop the "frame" to improve visualization
    energy = compute_energy(image)[1:-1, 1:-1]
    # uncomment to see the log-adjusted intensity.
    #energy = np.log(energy + 1)

    # normalization for visualization
    # darken the least value to black
    energy -= np.min(energy)
    # lighten the greatest value to white
    energy = energy / np.max(energy)
    # fit the value between [0, 255]
    energy *= 256
    energy = np.floor(energy)
    energy[energy == 256] = 255

    # convert values to an image
    energy_visualization = Image.fromarray(energy.astype(np.uint8), mode="L")
    energy_visualization.save("energy.png")

    # -------------------- vertical carving ---------------------

    # for an image of shape (height, width, channel)
    # build a visualization by gradually carving axis 1
    image = np.array(p).astype(int)
    original_shape = image.shape

    # sequence of frames to be animated
    sequence = []

    # cap number of seams to carve at 200
    for _ in tqdm(range(min([200, original_shape[1]])), desc='Carving vert seams'):
        
        # Create a frame for the seam to be carved away in red
        vertical_indices = tuple(np.arange(image.shape[0]))
        #print('start find_vertical_seam()')
        horizontal_indices = tuple(find_vertical_seam(image)) #EACH TIME THIS IS CALLED IT TAKES ABOUT 3 SECONDS. TOO LONG!!
        #print('end of find_vertical_seam()')
        vert_Count += 1
        #print('find_vertical_seam count : ' + str(vert_Count))

        image[vertical_indices, horizontal_indices, R] = 255
        image[vertical_indices, horizontal_indices, G] = 0
        image[vertical_indices, horizontal_indices, B] = 0

        # append black pixels to make up for pixels carved away
        sequence.append(Image.fromarray(
            np.append(image, np.zeros((
                original_shape[0],
                original_shape[1] - image.shape[1],
                original_shape[2],
            )), axis=1).astype(np.uint8)
        ))

        # carve the seam with a mask and reshape operation
        mask = np.full(image.shape, True, dtype=bool)
        mask[vertical_indices, horizontal_indices] = False

        image = image[mask].reshape((
            image.shape[0],
            image.shape[1] - 1,
            image.shape[2]
        ))

        # append black pixels to make up for pixels carved away
        sequence.append(Image.fromarray(
            np.append(image, np.zeros((
                original_shape[0],
                original_shape[1] - image.shape[1],
                original_shape[2],
            )), axis=1).astype(np.uint8)
        ))
        
    start_bewtween_fors = time.time() 
    
    # save the final, carved image
    final_image = Image.fromarray(image.astype(np.uint8))
    final_image.save("vertical_carving_final.png")

    #build GIF
    p.save(
        "vertical_carving.gif",
        save_all=True,
        append_images=sequence,
        #uncomment this line to create infinite looping GIF
        #loop=0,
        #uncomment this line to control the speed of GIF
        #duration=40,
    )

    # -------------------- horizontal carving -------------------

    # for an image of shape (height, width, channel)
    # build a visualization by gradually carving axis 0
    image = np.array(p).astype(int)
    original_shape = image.shape

    # sequence of frames to be animated
    sequence = []
    #print('line 276')
    end_betw_fors = time.time()
    print(f"Time taken to run the code was {end_betw_fors - start_bewtween_fors} seconds")   
    # cap number of seams to carve at 200
    for _ in tqdm(range(min([200, original_shape[0]])), desc='Carving horz seams'):
        # Create a frame for the seam to be carved away in red
        vertical_indices = tuple(find_horizontal_seam(image))
        horz_Count += 1
        #print('horz count ' + str(horz_Count))
        horizontal_indices = tuple(np.arange(image.shape[1]))
        image[vertical_indices, horizontal_indices, R] = 255
        image[vertical_indices, horizontal_indices, G] = 0
        image[vertical_indices, horizontal_indices, B] = 0

        # append black pixels to make up for pixels carved away
        sequence.append(Image.fromarray(
            np.append(image, np.zeros((
                original_shape[0] - image.shape[0],
                original_shape[1],
                original_shape[2],
            )), axis=0).astype(np.uint8)
        ))

        # carve the seam with a mask and reshape operation
        mask = np.full(image.shape, True, dtype=bool)
        mask[vertical_indices, horizontal_indices] = False

        # don't look at me I am hideous
        # (weird hack to make sure that pixels line up right)
        image = image.transpose(1, 0, 2)[mask.transpose(1, 0, 2)].reshape((
            image.shape[1],
            image.shape[0] - 1,
            image.shape[2],
        )).transpose(1, 0, 2)

        # append black pixels to make up for pixels carved away
        sequence.append(Image.fromarray(
            np.append(image, np.zeros((
                original_shape[0] - image.shape[0],
                original_shape[1],
                original_shape[2],
            )), axis=0).astype(np.uint8)
        ))

    # save the final, carved image
    final_image = Image.fromarray(image.astype(np.uint8))
    final_image.save("horizontal_carving_final.png")

    # build GIF
    p.save(
        "horizontal_carving.gif",
        save_all=True,
        append_images=sequence,
        # uncomment this line to create infinite looping GIF
        # loop=0,
        # uncomment this line to control the speed of GIF
        # duration=40,
    )


if __name__ == "__main__":
    start = time.time()
    main()
    end = time.time()
    print(f"Time taken to run the code was {end-start} seconds")
    